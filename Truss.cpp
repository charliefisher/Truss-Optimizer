#include "Truss.hpp"

Truss::Joint::Joint() {
	x=y=0;
	fixedX=fixedY=false;
	externalX=externalY=0;
}

Truss::Member::Member(){
	id = -1;
	joint1 = joint2 = NULL;
	length = force = 0;
}

Truss::Truss(unsigned int numJoints, unsigned int numMembers) {
	this->numJoints = numJoints;
	this->numMembers = numMembers;
	this->joints = new Joint[this->numJoints];
	this->pin = &joints[0];
	this->normalJoint = &joints[1];
}

Truss::~Truss() {
	delete[] joints;
}

Truss::Joint* Truss::getJoints() {
	return this->joints;
}

void Truss::solveGeneralSystem() {
	// assumes normal reaction force is horizontally or vertically aligned
	double momentAtPin = 0; // counterclockwise is positive
	// calculate moments about every joint
	for (unsigned int i = 2; i < this->numJoints; i++) {
		// if the joint has an external x (i.e. has any external force
		if (joints[i].externalY != 0) {
			momentAtPin += joints[i].x*joints[i].externalY;
			// do not need to calculate moment generated by x forces since external forces are only in y direction
//			momentAtPin -= joints[i].y*joints[i].externalX;
		}
	}

	if (normalJoint->x == 0) { // the reactions are vertically aligned
		 normalJoint->externalX = momentAtPin/normalJoint->y;
		 pin->externalX = -normalJoint->externalX;

		 for (unsigned int i = 2; i < this->numJoints; i++) {
			 pin->externalY -= joints[i].externalY;
		 }
	}
	else { // the reactions forces are horizontally aligned
		normalJoint->externalY = -momentAtPin/normalJoint->x;
		pin->externalX=0;
		for (unsigned int i = 1; i < this->numJoints; i++) {
			pin->externalY -= joints[i].externalY;
		}
	}
}

void Truss::jointEquations(Joint* j, double * xRow, double * yRow, double * externalX, double * externalY) {
	externalX = -j->externalX;
	externalY = -j->externalY;
	for(int i = 0; i < j->connections.size(); i++){
		xRow[j->connections[i]->id] = (j->connections[i]->joint1->x + j->connections[i]->joint2->x - 2*j->y)/connections->length;
		yRow[j->connections[i]->id] = (j->connections[i]->joint1->y + j->connections[i]->joint2->y - 2*j->y)/connections->length;
	}
}

bool Truss::solve() {
    //create matrix
    for (int i = 0; i < numJoints; i++){
    	jointEquations(joints[i], )
    }
	//solve system of equations given by all joints
    if (solveValid()){
        //change all the system parameters
        return true;
    } else {
        return false;
    }
}

bool Truss::solveValid(double * forces){
	for(int i= 0; i < forces->size(); i++){

	}
	//check all solved values, check if < 7
    //return true is all are, false otherwise.
}

bool Truss::checkIfBetterState(bool xDir, int jointNum, double increment){
	bool betterState = true;
	int numMembers = joints[jointNum].members.size;
	double * newLengths = new double[numMembers];
	double totalLen = 0;
	if(xDir) {
        joints[jointNum].x += increment;
    } else {
	    joints[jointNum].y += increment;
	}

	Node * curMember = joints[jointNum].members.head;
	memberNum = 0;
	while (curMember != NULL){
		double newLen = pow( pow(curMember->data->joint1->x - curMember->data->joint2->x , 2) + pow(curMember->data->joint1->x - curMember->data->joint2->x, 2 ) , 0.5);
		if(newLen > curMember->data->len  && newLen > 3){
			betterState = false;
			break;
		}
        totalLen += newLen;
		curMember = curmember->next;
		memberNum++;
	}
    if (totalLen < joints[jointNum].connectionLen && betterState){
        betterState = true;
    }

	if (betterState){
		for (int i = 0; i< memberNum; i++){
		    //change all the member geometry
		}

	} else {
        if(xDir) {
            joints[jointNum].x -= increment;
        } else {
            joints[jointNum].y -= increment;
        }
	}

	delete [] newLengths;
	newLengths = NULL;

	return betterState;
}

void Truss::optimize(){
	bool systemChanged = false;
	double movementIncrement = 0.25;

	while (movementIncrement > 0.01){
		systemChanged = true;
		while (systemChanged){
			systemChanged = false;
			for (int i  = 1; i < numJoints; i++){
				//testing horizontal movement
			    if (!joints[i].fixedX){
					betterState = checkIfBetterState(true, i, movementIncrement);
					if (betterState) {
					    if(solve()) {
                            systemChanged = true;
                        } else {
                            //move node back and adjust dimensions
					    }
					} else {
						betterState = checkIfBetterState(true, i, -movementIncrement);
                        if (betterState){
                            if (solve()){
                                systemChanged = true;
                            } else {
                                //move node back and adjust dimensions
                            }
                        }
					}
				}

			    //testing vertical movement
				if (!joints[i].fixedY){
                    betterState = checkIfBetterState(false, i, movementIncrement);
                    if (betterState) {
                        if(solve()) {
                            systemChanged = true;
                        } else {
                            //move node back and adjust dimensions
                        }
                    } else {
                        betterState = checkIfBetterState(false, i, -movementIncrement);
                        if (betterState){
                            if (solve()){
                                systemChanged = true;
                            } else {
                                //move node back and adjust dimensions
                            }
                        }
                    }
				}
				//both movement directions tested

			}
			//all joints have been moved
		}
		//system did not change on last iteration
		movementIncrement /= 4;
	}
	//movement increment <0.01
}



void Truss::output(ofstream & out){
	for(int i  = 0; i < numJoints; i++){
	out << "Joint " << i+1 << ":  ( " << joints[i].x << " , " << joints[i].y << " )";
	}
}





