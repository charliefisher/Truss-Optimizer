#include "Truss.hpp"

Truss::Joint::Joint() {
	x=y=0;
	fixedX=fixedY=false;
	externalX=externalY=0;
}

Truss::Member::Member(){
	id = -1;
	joint1 = joint2 = NULL;
	length = force = 0;
}

Truss::Truss(unsigned int numJoints, unsigned int numMembers) {
	this->numJoints = numJoints;
	this->numMembers = numMembers;
	this->joints = new Joint[this->numJoints];
	this->pin = &joints[0];
	this->normalJoint = &joints[1];

}

Truss::~Truss() {
	delete[] joints;
}

Truss::Joint* Truss::getJoints() {
	return this->joints;
}

void Truss::solveGeneralSystem() {
	// assumes normal reaction force is horizontally or vertically aligned
	double momentAtPin = 0; // counterclockwise is positive
	// calculate moments about every joint
	for (unsigned int i = 2; i < this->numJoints; i++) {
		// if the joint has an external x (i.e. has any external force
		if (joints[i].externalY != 0) {
			momentAtPin += joints[i].x*joints[i].externalY;
			// do not need to calculate moment generated by x forces since external forces are only in y direction
//			momentAtPin -= joints[i].y*joints[i].externalX;
		}
	}

	if (normalJoint->x == 0) { // the reactions are vertically aligned
		 normalJoint->externalX = momentAtPin/normalJoint->y;
		 pin->externalX = -normalJoint->externalX;

		 for (unsigned int i = 2; i < this->numJoints; i++) {
			 pin->externalY -= joints[i].externalY;
		 }
	}
	else { // the reactions forces are horizontally aligned
		normalJoint->externalY = -momentAtPin/normalJoint->x;
		pin->externalX=0;
		for (unsigned int i = 1; i < this->numJoints; i++) {
			pin->externalY -= joints[i].externalY;
		}
	}
}

void Truss::initialSolve(){
	solveGeneralSystem();

	mat equations = mat(numJoints*2, numMembers, fill::zeros);
	vec external = vec(numJoints*2, fill::zeroes);
	vec forces = vec(numMembers, fill::zeroes);

	for (int i = 0; i < numJoints; i++){
		Joint * j = joints[i];
		external.at(i*2) = -joints[i]->externalX;
		externat.at(i*2+1) = -joints[i]->externalY;
		for(int k = 0; i < joints[i]->connections.size(); i++) {
			equations.at(i*2, k) = joints[i]->connections[j]->joint1->x + j->connections[i]->joint2->x - 2*j->y)/connections->lengt
		}
	}

	solve(forces, equations, external);

	for (int i = 0; i < numMembers; i++){
		validForces[i] = forces(i);
	}
}

bool Truss::solveInternal() {
    solveGeneralSystem();

	mat equations = mat(numJoints*2, numMembers, fill::zeros);
    vec external = vec(numJoints*2, fill::zeroes);
    vec forces = vec(numMembers, fill::zeroes);

    for (int i = 0; i < numJoints; i++){
    	Joint * j = joints[i];
		external.at(i*2) = -joints[i]->externalX;
		externat.at(i*2+1) = -joints[i]->externalY;
		for(int k = 0; i < joints[i]->connections.size(); i++) {
			equations.at(i*2, k) = joints[i]->connections[j]->joint1->x + j->connections[i]->joint2->x - 2*j->y)/connections->lengt
		}
    }

    solve(forces, equations, external);

    bool solveValid = true;
    for (int i = 0; i < numMembers; i++){
    	if(forces(i) > validForces[i] && forces(i) > 7){
    		solveValid = false;
    		break;
    	}
    }

    if (solveValid){
		for (int i = 0; i < numMembers; i++){
			validForces[i] = forces(i);
		}
        return true;
    } else {
        return false;
    }
}

double * Truss::checkIfBetterState(bool xDir, int jointNum, double increment) {
	bool betterState = true;
	Joint *joint = joints + jointNum;
	int numMembers = joint->connections.size();
	double * newLengths = new double[numMembers];
	double * oldLengths = NULL;
	double totalLen = 0;

	//changes x or y value based on the direction given
	if(xDir) {
        joints[jointNum].x += increment;
    } else {
	    joints[jointNum].y += increment;
	}

	for (int i = 0; i < numMembers; i++){
		newLengths[i] = pow( pow(joint->connections[i]->data->joint1->x - joint->connections[i]->data->joint2->x , 2) + pow(joint->connections[i]->data->joint1->x - joint->connections[i]->data->joint2->x, 2 ) , 0.5);
		if(newLengths[i] > joint->connections[i]->length  && newLen > 3){
			int betterState = false;
			break;
		}
        totalLen += newLen;
	}

    if (totalLen >= joint->connectionLen){
        betterState = false;
    }
	// if new state is better, copy length values into old length and
	if (betterState){
		oldLengths = new double[numMembers];
		for (int i = 0; i< numMembers); i++){
		    //change all the member geometry
			oldLengths[i] = joint->connections[i]->length;
		    joint->connections[i]->length = newLengths[i]
		}

	}
	//reverts x or y value based on direction given if new state is not better
	else {
        if(xDir) {
            joints[jointNum].x -= increment;
        } else {
			joints[jointNum].y -= increment;
		}
	}

	delete [] newLengths;
	newLengths = NULL;

	return oldLengths;
}

void Truss::revertLengths(int jointNum, double * oldLengths){
	for (int i = 0; i < joints[jointNum].connections->length; i++){
		joints[jointNum].connections->length = oldLengths[i];
	}
}



void Truss::optimize(){
	bool systemChanged = false;
	double movementIncrement = 0.25;
	double * oldLengths = NULL;

	while (movementIncrement > 0.01){
		systemChanged = true;
		while (systemChanged){
			systemChanged = false;
			for (int i  = 1; i < numJoints; i++){
				//testing horizontal movement
			    if (!joints[i].fixedX){
					oldLengths = checkIfBetterState(true, i, movementIncrement);
					if (oldLengths != NULL) {
					    if(solve()) {
                            systemChanged = true;
                        } else {
							joints[i].x -= movementIncrement;
					    	revertLengths(i, oldLengths);//move node back and adjust dimensions
					    }
					} else {
						oldLengths = checkIfBetterState(true, i, -movementIncrement);
                        if (oldLengths != NULL){
                            if (solve()){
                                systemChanged = true;
                            } else {
                                joints[i].x += movementIncrement;
                            	revertLengths(i, oldLengths);
                            }
                        }
					}
					if(oldLengths != NULL){
						delete [] oldLengths;
						oldLengths = NULL;
					}

				}

			    //testing vertical movement
				if (!joints[i].fixedY){
					oldLengths = checkIfBetterState(false, i, movementIncrement);
					if (oldLengths != NULL) {
						if(solve()) {
							systemChanged = true;
						} else {
							joints[i].x -= movementIncrement;
							revertLengths(i, oldLengths);//move node back and adjust dimensions
						}
					} else {
						oldLengths = checkIfBetterState(false, i, -movementIncrement);
						if (oldLengths != NULL){
							if (solve()){
								systemChanged = true;
							} else {
								joints[i].x += movementIncrement;
								revertLengths(i, oldLengths);
							}
						}
					}
					if(oldLengths != NULL){
						delete [] oldLengths;
						oldLengths = NULL;
					}

				}
				//both movement directions tested

			}
			//all joints have been moved
		}
		//system did not change on last iteration
		movementIncrement /= 4;
	}
	//movement increment <0.01
}



void Truss::output(ofstream & out){
	for(int i  = 0; i < numJoints; i++){
	out << "Joint " << i+1 << ":  ( " << joints[i].x << " , " << joints[i].y << " )";
	}

}





